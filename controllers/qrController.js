// controllers/qrController.js
const QRCode = require('qrcode');
const Jimp = require('jimp');
const path = require('path');
const fs = require('fs');
const QRModel = require('../models/QR');
const { sendPhotoToTelegram } = require('../utils/telegram');

const UPLOAD_DIR = process.env.UPLOAD_DIR || './uploads';
const BASE_URL = process.env.BASE_URL || 'http://localhost:4000';

function safeFileName(prefix='qr') {
  return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2,8)}.png`;
}

// Generate basic QR
exports.generateBasic = async (req, res) => {
  try {
    const { url } = req.body;
    if (!url) return res.status(400).json({ error: 'url required' });

    const filename = safeFileName('basic');
    const outPath = path.join(UPLOAD_DIR, filename);

    await QRCode.toFile(outPath, url, { errorCorrectionLevel: 'M' });

    const stats = fs.statSync(outPath);
    const qr = await QRModel.create({ url, filename, path: outPath, size: stats.size });

    res.json({
      ok: true,
      url: `${BASE_URL}/uploads/${filename}`,
      id: qr._id,
      filename
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'generate failed', details: err.message });
  }
};

// Generate advanced QR with watermark
exports.generateAdvanced = async (req, res) => {
  try {
    let { url, watermarkText } = req.body;
    if (!url) return res.status(400).json({ error: 'url required' });
    watermarkText = watermarkText || 'PUJO DEV @FoundCount';

    // create QR buffer
    const qrBuffer = await QRCode.toBuffer(url, {
      errorCorrectionLevel: 'H',
      margin: 2,
      width: 1000
    });

    const image = await Jimp.read(qrBuffer);
    image.background(0xFFFFFFFF);

    const width = image.bitmap.width;
    const height = image.bitmap.height;

    const font = await Jimp.loadFont(Jimp.FONT_SANS_32_BLACK);
    const textWidth = Jimp.measureText(font, watermarkText);
    const textHeight = Jimp.measureTextHeight(font, watermarkText, width);

    const x = (width - textWidth) / 2;
    const y = height - textHeight - 20;

    const rectHeight = textHeight + 14;
    const rectWidth = textWidth + 14;
    const rectX = x - 7;
    const rectY = y - 7;

    const rect = new Jimp(rectWidth, rectHeight, 0xFFFFFFFF);
    rect.opacity(0.95);
    image.composite(rect, rectX, rectY);

    image.print(font, x, y, watermarkText);

    // center circle logo
    const circleSize = Math.floor(width * 0.12);
    const circle = new Jimp(circleSize, circleSize, 0x000000FF);
    circle.circle();
    const logoX = (width - circleSize) / 2;
    const logoY = (height - circleSize) / 2;
    image.composite(circle, logoX, logoY);

    const fontWhite = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);
    image.print(fontWhite, logoX + (circleSize/2 - 8), logoY + (circleSize/2 - 16), 'P');

    // save
    const filename = safeFileName('advanced');
    const outPath = path.join(UPLOAD_DIR, filename);
    await image.quality(95).writeAsync(outPath);

    const stats = fs.statSync(outPath);
    const qr = await QRModel.create({ url, filename, path: outPath, size: stats.size });

    res.json({
      ok: true,
      url: `${BASE_URL}/uploads/${filename}`,
      id: qr._id,
      filename
    });

  } catch (err) {
    console.error('advanced error', err);
    res.status(500).json({ error: 'advanced failed', details: err.message });
  }
};

// Send to Telegram by filename
exports.sendToTelegram = async (req, res) => {
  try {
    const { filename, caption } = req.body;
    if (!filename) return res.status(400).json({ error: 'filename required' });

    const filePath = path.join(UPLOAD_DIR, filename);
    if (!fs.existsSync(filePath)) return res.status(404).json({ error: 'file not found' });

    const realCaption = caption || 'ðŸš€ QR Code Generated by PUJO DEV\nðŸ“± Developer: @FoundCount\nðŸ”— Channel: https://t.me/PUJODIVED';
    const result = await sendPhotoToTelegram(filePath, realCaption);

    if (result && result.ok) {
      return res.json({ ok: true, telegram: result });
    } else {
      return res.status(500).json({ ok: false, telegram: result });
    }
  } catch (err) {
    console.error('sendToTelegram error', err);
    res.status(500).json({ error: 'send failed', details: err.message });
  }
};

// List QR history
exports.listQRs = async (req, res) => {
  try {
    const rows = await QRModel.find().sort({ createdAt: -1 }).limit(200);
    res.json({ ok: true, items: rows });
  } catch (err) {
    res.status(500).json({ error: 'list failed', details: err.message });
  }
};